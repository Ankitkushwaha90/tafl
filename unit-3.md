Regular and Non-Regular Grammars: Context Free Grammar(CFG)-Definition, Derivations,
Languages, Derivation Trees and Ambiguity, Regular Grammars-Right Linear and Left Linear
grammars, Conversion of FA into CFG and Regular grammar into FA, Simplification of CFG, Normal
Forms- Chomsky Normal Form(CNF), Greibach Normal Form (GNF), Chomsky Hierarchy,
Programming problems based on the properties of CFGs.

Regular and Non-Regular Grammars
1. Context-Free Grammar (CFG)
1.1 Definition
A Context-Free Grammar (CFG) is a formal grammar where each production rule is of the form:

A → α

A is a non-terminal symbol.

α is a string of terminals and/or non-terminals (can be empty).

A CFG is defined by a 4-tuple:

G = (V, Σ, P, S)

V: Finite set of non-terminal symbols.

Σ: Finite set of terminal symbols (alphabet).

P: Finite set of production rules.

S: Start symbol (S ∈ V).

1.2 Derivations
A derivation is a sequence of replacements of non-terminals using production rules to generate a string of terminals.

Leftmost Derivation: Always replace the leftmost non-terminal first.

Rightmost Derivation: Always replace the rightmost non-terminal first.

Example:
Consider the CFG:

S → aSb | ε

Derivation of aabb:

Leftmost: S → aSb → aaSbb → aabb

Rightmost: S → aSb → aaSbb → aabb

1.3 Languages
The language generated by a CFG, L(G), is the set of all strings that can be derived from the start symbol S.

Example:
For the CFG:

S → aSb | ε

L(G) = {aⁿbⁿ | n ≥ 0}

1.4 Derivation Trees
A derivation tree (parse tree) is a graphical representation of a derivation.

Root: Start symbol S.

Leaves: Terminals or ε.

Internal Nodes: Non-terminals.

Example:
For the string aabb:

Copy
      S
     /|\
    a S b
     /|\
    a S b
       |
       ε
1.5 Ambiguity
A CFG is ambiguous if there exists at least one string in L(G) that has more than one derivation tree (or more than one leftmost/rightmost derivation).

Example:
Consider the CFG:

S → S + S | S * S | a

The string a + a * a has two derivation trees:

S → S + S → a + S → a + S * S → a + a * a

S → S * S → S + S * S → a + a * a

This grammar is ambiguous.

2. Regular Grammars
2.1 Right Linear and Left Linear Grammars
A regular grammar is a CFG where all production rules are of one of the following forms:

Right Linear Grammar:

A → aB

A → a

A → ε
(where A, B are non-terminals, a is a terminal).

Left Linear Grammar:

A → Ba

A → a

A → ε

Example:
Right Linear Grammar for a*b:

S → aS | b

Left Linear Grammar for a*b:

S → Sa | b

2.2 Conversion of FA into CFG
To convert a Finite Automaton (FA) into a CFG:

Create a non-terminal for each state in the FA.

For each transition δ(A, a) = B, add a production rule A → aB.

For each accepting state A, add a production rule A → ε.

Example:
FA for a*b:

States: q0, q1

Transitions: q0 → q0 on a, q0 → q1 on b

Accepting state: q1

CFG:

q0 → aq0 | bq1

q1 → ε

2.3 Conversion of Regular Grammar into FA
To convert a regular grammar into an FA:

Create a state for each non-terminal.

For each production rule A → aB, add a transition δ(A, a) = B.

For each production rule A → a, add a transition δ(A, a) = F (where F is an accepting state).

Mark the start state as the start symbol of the grammar.

Example:
Right Linear Grammar for a*b:

S → aS | b

FA:

States: S, F

Transitions: S → S on a, S → F on b

Accepting state: F

3. Simplification of CFG
Simplification involves removing unnecessary symbols and productions from a CFG. Steps include:

Eliminate ε-productions: Remove rules of the form A → ε.

Eliminate unit productions: Remove rules of the form A → B.

Eliminate useless symbols: Remove non-terminals and terminals that do not contribute to generating any string in L(G).

4. Normal Forms
4.1 Chomsky Normal Form (CNF)
A CFG is in CNF if all production rules are of the form:

A → BC

A → a
(where A, B, C are non-terminals, a is a terminal).

Steps to Convert to CNF:
Eliminate ε-productions and unit productions.

Replace terminals in longer rules with new non-terminals.

Break long rules into smaller rules of length 2.

Example:
Convert the CFG:

S → aSb | ε
to CNF:

Eliminate ε: S → aSb | ab

Replace terminals: S → XSX | XY, X → a, Y → b

Break long rules: S → XS', S' → SX, S → XY

4.2 Greibach Normal Form (GNF)
A CFG is in GNF if all production rules are of the form:

A → aα
(where a is a terminal, α is a string of non-terminals).

Steps to Convert to GNF:
Convert to CNF.

Eliminate left recursion.

Rewrite rules to start with a terminal.

5. Chomsky Hierarchy
The Chomsky Hierarchy classifies formal grammars into four levels:

Type 0: Unrestricted grammars (Turing machines).

Type 1: Context-sensitive grammars (linear bounded automata).

Type 2: Context-free grammars (pushdown automata).

Type 3: Regular grammars (finite automata).

6. Programming Problems Based on CFGs
Check if a string is generated by a CFG:

Use a parsing algorithm (e.g., CYK algorithm).

Convert a CFG to CNF or GNF:

Implement the steps for simplification and normalization.

Detect ambiguity in a CFG:

Check if a string has more than one parse tree.

Simulate a PDA for a CFG:

Implement a pushdown automaton to recognize strings in L(G).

Conclusion
Understanding regular and non-regular grammars, CFGs, and their properties is essential for formal language theory and compiler design. Key concepts include derivations, derivation trees, ambiguity, simplification, and normal forms. These concepts are foundational for solving programming problems and designing efficient algorithms for language recognition and parsing.
